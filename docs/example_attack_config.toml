# This file contains the mapping: page in binary -> physical page frame
# If binary pages have multiple junction bits, they are grouped in the `victim_frames.victim_bits` array
# In the paper, we call this the "loader map"
# The addresses are physical addresses when not explicitly specified
# This file is generated by the `generate_attack_config.py` script so you should not write this by hand

hammer_count = 1000000 # the number of aggressor accesses when hammering
segment_virt_addr = 0x404000 # the start virtual address at which the PT_NULL segment should be loaded into memory (set by the linker)

[[victim_frames]]
page_file_offset = 0x8000 # offset (wrt the beginning of the binary file) of a target page
frame_addr = 0x4e2c5000 # physical frame in which the target page should get loaded
victim_bits = [{offset = 0x2, bitflip = '3-', aggr_pattern_key = '0'}] 
  # `offset` is the byte offset in the target page of the target byte containing a junction bit
  # `bitflip` is the expected bit flip (for debugging, this info should not be provided in a "real world" deployment of this system)
  # It contains the bit offset within the target byte, and the flip direction
  # `aggr_pattern_key` is the id of the corresponding aggressor pattern below


[[victim_frames]]
page_file_offset = 0x3000
frame_addr = 0x4e231000
victim_bits = [
  {offset = 0x0db, bitflip = '1-', aggr_pattern_key = '0'},
  {offset = 0x0db, bitflip = '6-', aggr_pattern_key = '0'},
  {offset = 0x0db, bitflip = '5+', aggr_pattern_key = '1'},
  {offset = 0x123, bitflip = '1-', aggr_pattern_key = '0'},
  {offset = 0xb00, bitflip = '7+', aggr_pattern_key = 'walter'}
]

[aggressor_patterns]
0 = '0x4e2a2000(0x0),0x4e2e6000(0x0)' # format: aggr_id = aggressor1(init_value_aggressor1),aggressor2(init_value_aggressor2),...
1 = '0x12345000(0xff),0x54321000(0xff)'
walter = '0x67891000(0x0),0x13243000(0x0)'
